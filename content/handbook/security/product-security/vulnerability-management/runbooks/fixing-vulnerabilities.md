---
title: "Fixing vulnerabilities"
description: "Provides actionable guidance on how to resolve specific vulnerability types from specific sources for team members"
controlled_document: true
---

## Overview

The purpose of this runbook is to define common sources and types of vulnerability, and typically the work required to remediate the vulnerability finding.
This runbook is divided into sections based on the source of a vulnerability findings, and further broken down into types of sources. For example, it is common for vulnerability findigns to originate from automated scans in CI pipelines. There are multiple subtypes of automated security scans, such as container scanning, dependency scanning, secrets scanning which all have their own sub-sections detailing a typical resolution workflow.

## Source: Security Scanners

Automated security scanners are the source of the majority of vulnerability findings at GitLab. These can range from infrastructure security scanning, or scans run against GitLab assets we ship out to users, such as container images and software packages we publish.

### Source: Container Scanners

Container scanners will scan built container images for software components, binaries, and OS package metadata (such as RPM or .deb package databases) embeedded in the image for known-vulnerable components. Some scanners will also detect language libraries such as Ruby gems, Go libraries and Python modules which carry known vulnerabilities and have been deployed inside an image. In general, for container scan findings, if a fix has been released, updating the detected component to the version indicated as fixed alongside the detection will address the finding, and no further work will be required. Complications can arise if upgrading a specific component causes incompatibility with other components and deployed code inside the container, such as incompatible Ruby gem versions not yet being tested against GitLab in a GitLab-published `gitlab-ee` or `gitlab-ce` image. In these cases, further work may be required to validate the upgrade will not cause any problems if upgraded.

#### Type: 3rd Party OS Dependency

In the case of a vulnerability finding naming OS packages present inside a container image as vulnerable to a given vulnerability (i.e. a CVE), one of the two remediations will often apply:

- Updating any base images sources from vendors, or base images which in turn are based on vendor images, to the latest vendor-released base.
- Using the package manager (i.e. `apt`, `yum` or `microdnf`) to upgrade to the fixed package version as part of either a base image build or the build of the impact image

 Normally, using the package manager to upgrade packages, if available for the type of base image, during build time, is considered good practice, as it will often prevent findings like this from being detected at all if the image is built frequently enough and the vendor is pushing fixed packages quickly enough. Typically updated packages will be made available before updated base images from most vendors. If they are not made available in a timely manner, an [SLA exception]({{< ref "../sla-exceptions.md" >}}) may be appropriate. In case there is no package management, as is often the case in distroless images, the only remediation may to be update the base image from the distroless image vendor, or build a fixed version ourselves as part of the image build process. This last option should only be pursued, given the time investment, if a fix is needed and the vendor has indicated they will not be making a fix available.

#### Type: Language libraries/dependencies

Some container scanning tools have the ability to detect vulnerabilities in language libraries (such as Python modules, Ruby gems) or even to extract package information out of compiled Go binaries. These scanners will raise vulnerability findings for vulnerable components if they are detected embedded into a container image, as is often the case when built software such as GitLab is deployed as a ready-built contianer image for distribution to users.

Similar to 3rd party OS dependencies, the remediation here is typically to update the impacted library or module, and ship an updated container image to users. If there are delays in a vulnerability being addressed in a component we depend on, it may be necessary to open an [SLA exception]({{< ref "../sla-exceptions.md" >}}) or assess alternate libraries which are not vulnerable, but provide similar functionality. Balancing the effort to move to different library should be done against the likelihood the vulnerability will be addressed upstream in the existing library, and how long that is likely to take.

### Source: SAST

SAST findings typically represent known and suspected code patterns which may introduce a vulnerability into a codebase. Typically, these findings will have remediation advice associated with them based on the specific finding, however impacts to the functionality of the code where the vulnerability is detected should be assessed by the appropriate development group to ensure the advice given by the scanner will not cause any other issues if applied. Often, there are multiple ways to address SAST findings, each with different complexity, benefits, and negatives which should be considered.

Additionally to this, if development groups have novel ways in which a SAST vulnerability finding can be effectively mitigated, it may be necessary to add specific code comments instructing the scanner to ignore a specific code pattern in the future, even once a solution is applied. Many SAST scanners look for simple patterns in code or the usage of specific language libaries, and even code which is secure can sometimes generate findings.

Further to this, if the vulnerability finding is not actually exploitable to begin with, and the code highlighted in the finding is not vulnerable, adding the code comments/annotations to the detected code to instruct the scanner to ignore this code for this finding in the future may be necessary. If the finding is not exploitable (a false positive) and the code comment/annotation results in the finding not being detected upon rescan, that is also an acceptable solution.
